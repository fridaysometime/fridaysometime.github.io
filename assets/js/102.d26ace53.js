(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{222:function(s,t,e){"use strict";e.r(t);var a=e(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"python之内存回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python之内存回收机制","aria-hidden":"true"}},[s._v("#")]),s._v(" Python之内存回收机制")]),s._v(" "),e("p",[s._v("现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。 对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。 python里也同java一样采用了垃圾收集机制，不过不一样的是: python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。")]),s._v(" "),e("p",[s._v("引用计数机制：")]),s._v(" "),e("p",[s._v("python里每一个东西都是对象，它们的核心就是一个结构体："),e("code",[s._v("PyObject")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("typedef struct_object {\n    int ob_refcnt;\n    struct_typeobject *ob_type;\n} PyObject;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("#define Py_INCREF(op)   ((op)->ob_refcnt++) //增加计数\n#define Py_DECREF(op) \\ //减少计数\n    if (--(op)->ob_refcnt != 0) \\\n        ; \\\n    else \\\n        __Py_Dealloc((PyObject *)(op))\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("当引用计数为0时，该对象生命就结束了。")]),s._v(" "),e("h5",{attrs:{id:"引用计数机制的优点："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用计数机制的优点：","aria-hidden":"true"}},[s._v("#")]),s._v(" 引用计数机制的优点：")]),s._v(" "),e("ul",[e("li",[s._v("简单")]),s._v(" "),e("li",[s._v("实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。")])]),s._v(" "),e("h5",{attrs:{id:"引用计数机制的缺点："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用计数机制的缺点：","aria-hidden":"true"}},[s._v("#")]),s._v(" 引用计数机制的缺点：")]),s._v(" "),e("ul",[e("li",[s._v("维护引用计数消耗资源")]),s._v(" "),e("li",[s._v("循环引用")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("list1 = []\nlist2 = []\nlist1.append(list2)\nlist2.append(list1)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。 对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(标记清除和分代收集)")])])}],!1,null,null,null);t.default=n.exports}}]);