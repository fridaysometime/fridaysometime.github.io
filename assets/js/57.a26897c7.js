(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{267:function(e,n,s){"use strict";s.r(n);var t=s(0),a=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"leetcode-minimum-depth-of-binary-tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-minimum-depth-of-binary-tree","aria-hidden":"true"}},[e._v("#")]),e._v(" leetcode-Minimum Depth of Binary Tree")]),e._v(" "),s("p",[e._v("Given a binary tree, find its minimum depth.")]),e._v(" "),s("p",[e._v("The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.")]),e._v(" "),s("p",[s("strong",[e._v("Note:")]),e._v(" A leaf is a node with no children.")]),e._v(" "),s("p",[s("strong",[e._v("Example:")])]),e._v(" "),s("p",[e._v("Given binary tree "),s("code",[e._v("[3,9,20,null,null,15,7]")]),e._v(",")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    3\n   / \\\n  9  20\n    /  \\\n   15   7\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("return its minimum depth = 2.")]),e._v(" "),s("h1",{attrs:{id:"solution"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#solution","aria-hidden":"true"}},[e._v("#")]),e._v(" solution:")]),e._v(" "),s("p",[e._v("分几种情况考虑：1，树为空，则为0。 2，根节点如果只存在左子树或者只存在右子树，则返回值应为左子树或者右子树的（最小深度+1）。 3，如果根节点的左子树和右子树都存在，则返回值为（左右子树的最小深度的较小值+1）。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('class TreeNode:\n    def init(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def minDepth(self, root):\n        """\n        :type root: TreeNode\n        :rtype: int\n        """\n        if root is None:\n            return 0\n        elif root.left is not None and root.right is None:\n            return self.minDepth(root.left)+1\n        elif root.right is not None and root.left is None:\n            return self.minDepth(root.right)+1\n        else:\n            return min(self.minDepth(root.right),self.minDepth(root.left))+1\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br")])]),s("p",[e._v("class TreeNode:\ndef "),s("strong",[e._v("init")]),e._v("(self, x):\nself.val = x\nself.left = None\nself.right = None")]),e._v(" "),s("p",[e._v("​")])])}],!1,null,null,null);n.default=a.exports}}]);